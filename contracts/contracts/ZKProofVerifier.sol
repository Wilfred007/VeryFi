// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title ZKProofVerifier
 * @dev Verifies zero-knowledge proofs for ECDSA signatures
 * This contract handles the cryptographic verification of ZK proofs
 * generated by the Noir circuit system
 */
contract ZKProofVerifier is Ownable, ReentrancyGuard {
    
    // Verification key structure for different proof types
    struct VerificationKey {
        bytes32 keyHash;
        bytes vkData; // Verification key data
        bool isActive;
        uint256 createdAt;
    }

    // Proof verification result
    struct VerificationResult {
        bool isValid;
        bytes32 proofHash;
        bytes32 publicInputsHash;
        uint256 verifiedAt;
        address verifier;
    }

    // Mapping of proof type to verification key
    mapping(string => VerificationKey) public verificationKeys;
    
    // Mapping of proof hash to verification result
    mapping(bytes32 => VerificationResult) public verificationResults;
    
    // Supported proof types
    string[] public supportedProofTypes;
    
    // Statistics
    uint256 public totalVerifications;
    uint256 public successfulVerifications;

    // Events
    event VerificationKeyUpdated(
        string indexed proofType,
        bytes32 keyHash
    );
    
    event ProofVerified(
        bytes32 indexed proofHash,
        string proofType,
        bool isValid,
        address indexed verifier
    );

    // Custom errors
    error InvalidProofType();
    error InvalidVerificationKey();
    error InvalidProofData();
    error ProofAlreadyVerified();

    constructor() Ownable(msg.sender) {}

    /**
     * @dev Set verification key for a proof type
     */
    function setVerificationKey(
        string calldata proofType,
        bytes calldata vkData
    ) external onlyOwner {
        bytes32 keyHash = keccak256(vkData);
        
        // Add to supported types if new
        if (verificationKeys[proofType].createdAt == 0) {
            supportedProofTypes.push(proofType);
        }
        
        verificationKeys[proofType] = VerificationKey({
            keyHash: keyHash,
            vkData: vkData,
            isActive: true,
            createdAt: block.timestamp
        });

        emit VerificationKeyUpdated(proofType, keyHash);
    }

    /**
     * @dev Verify a zero-knowledge proof
     * @param proofType Type of proof (e.g., "ecdsa_signature_verification")
     * @param proofData The ZK proof data
     * @param publicInputs Public inputs for the proof
     * @return isValid Whether the proof is valid
     */
    function verifyProof(
        string calldata proofType,
        bytes calldata proofData,
        bytes calldata publicInputs
    ) external nonReentrant returns (bool isValid) {
        // Check if proof type is supported
        if (verificationKeys[proofType].createdAt == 0 || !verificationKeys[proofType].isActive) {
            revert InvalidProofType();
        }

        // Generate proof hash
        bytes32 proofHash = keccak256(abi.encodePacked(proofData, publicInputs));
        
        // Check if already verified
        if (verificationResults[proofHash].verifiedAt != 0) {
            return verificationResults[proofHash].isValid;
        }

        // Verify the proof (simplified for demo - in production, use actual ZK verification)
        isValid = _verifyZKProof(proofType, proofData, publicInputs);

        // Store verification result
        bytes32 publicInputsHash = keccak256(publicInputs);
        verificationResults[proofHash] = VerificationResult({
            isValid: isValid,
            proofHash: proofHash,
            publicInputsHash: publicInputsHash,
            verifiedAt: block.timestamp,
            verifier: msg.sender
        });

        // Update statistics
        totalVerifications++;
        if (isValid) {
            successfulVerifications++;
        }

        emit ProofVerified(proofHash, proofType, isValid, msg.sender);
        return isValid;
    }

    /**
     * @dev Internal function to verify ZK proof
     * In a production system, this would integrate with actual ZK verification libraries
     */
    function _verifyZKProof(
        string calldata proofType,
        bytes calldata proofData,
        bytes calldata publicInputs
    ) internal view returns (bool) {
        // For ECDSA signature verification proofs, we perform basic validation
        if (keccak256(bytes(proofType)) == keccak256(bytes("ecdsa_signature_verification"))) {
            return _verifyECDSAProof(proofData, publicInputs);
        }
        
        // Default: basic proof validation
        return _basicProofValidation(proofData, publicInputs);
    }

    /**
     * @dev Verify ECDSA signature proof
     */
    function _verifyECDSAProof(
        bytes calldata proofData,
        bytes calldata publicInputs
    ) internal pure returns (bool) {
        // Basic validation - check proof and inputs are not empty
        if (proofData.length == 0 || publicInputs.length == 0) {
            return false;
        }

        // In a real implementation, this would:
        // 1. Parse the proof data and public inputs
        // 2. Verify the ZK proof using the verification key
        // 3. Check that the public inputs match expected format
        
        // For demo purposes, we'll do basic validation
        // Check that we have expected public input structure for ECDSA proof
        // Expected: message_hash (32 bytes) + public_key_x (32 bytes) + public_key_y (32 bytes)
        if (publicInputs.length < 96) { // 32 + 32 + 32 bytes minimum
            return false;
        }

        // Check proof data has reasonable size (simplified)
        if (proofData.length < 64) {
            return false;
        }

        return true;
    }

    /**
     * @dev Basic proof validation for other proof types
     */
    function _basicProofValidation(
        bytes calldata proofData,
        bytes calldata publicInputs
    ) internal pure returns (bool) {
        // Basic checks
        return proofData.length > 0 && publicInputs.length > 0;
    }

    /**
     * @dev Batch verify multiple proofs
     */
    function batchVerifyProofs(
        string[] calldata proofTypes,
        bytes[] calldata proofDataArray,
        bytes[] calldata publicInputsArray
    ) external nonReentrant returns (bool[] memory results) {
        require(
            proofTypes.length == proofDataArray.length && 
            proofDataArray.length == publicInputsArray.length,
            "Array length mismatch"
        );

        results = new bool[](proofTypes.length);
        
        for (uint256 i = 0; i < proofTypes.length; i++) {
            results[i] = this.verifyProof(
                proofTypes[i],
                proofDataArray[i],
                publicInputsArray[i]
            );
        }

        return results;
    }

    /**
     * @dev Get verification result for a proof
     */
    function getVerificationResult(bytes32 proofHash)
        external
        view
        returns (
            bool isValid,
            bytes32 publicInputsHash,
            uint256 verifiedAt,
            address verifier
        )
    {
        VerificationResult storage result = verificationResults[proofHash];
        return (
            result.isValid,
            result.publicInputsHash,
            result.verifiedAt,
            result.verifier
        );
    }

    /**
     * @dev Get verification key for a proof type
     */
    function getVerificationKey(string calldata proofType)
        external
        view
        returns (
            bytes32 keyHash,
            bytes memory vkData,
            bool isActive,
            uint256 createdAt
        )
    {
        VerificationKey storage vk = verificationKeys[proofType];
        return (vk.keyHash, vk.vkData, vk.isActive, vk.createdAt);
    }

    /**
     * @dev Get all supported proof types
     */
    function getSupportedProofTypes() external view returns (string[] memory) {
        return supportedProofTypes;
    }

    /**
     * @dev Get verification statistics
     */
    function getVerificationStats()
        external
        view
        returns (
            uint256 total,
            uint256 successful,
            uint256 successRate
        )
    {
        total = totalVerifications;
        successful = successfulVerifications;
        successRate = total > 0 ? (successful * 100) / total : 0;
        return (total, successful, successRate);
    }

    /**
     * @dev Disable a verification key
     */
    function disableVerificationKey(string calldata proofType) external onlyOwner {
        if (verificationKeys[proofType].createdAt == 0) {
            revert InvalidProofType();
        }
        
        verificationKeys[proofType].isActive = false;
    }

    /**
     * @dev Enable a verification key
     */
    function enableVerificationKey(string calldata proofType) external onlyOwner {
        if (verificationKeys[proofType].createdAt == 0) {
            revert InvalidProofType();
        }
        
        verificationKeys[proofType].isActive = true;
    }
}
